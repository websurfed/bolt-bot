// @ts-check

import { readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { build } from 'tsup';
import { Colors, erase, findCommandKitConfig, panic, write } from './common.mjs';
import ora from 'ora';

export async function bootstrapProductionBuild(config) {
    const {
        sourcemap = false,
        minify = false,
        outDir = 'dist',
        antiCrash = true,
        src,
        main,
        requirePolyfill: polyfillRequire,
    } = await findCommandKitConfig(config);

    const status = ora('Creating optimized production build...\n').start();
    const start = performance.now();

    erase(outDir);

    try {
        await build({
            clean: true,
            format: ['esm'],
            dts: false,
            skipNodeModulesBundle: true,
            minify,
            shims: true,
            banner: {
                js: '/* Optimized production build generated by CommandKit */',
            },
            sourcemap,
            keepNames: true,
            outDir,
            silent: true,
            watch: false,
            entry: [src, '!dist', '!.commandkit', `!${outDir}`],
        });

        await injectShims(outDir, main, antiCrash, polyfillRequire);

        status.succeed(
            Colors.green(`Build completed in ${(performance.now() - start).toFixed(2)}ms!`),
        );
        write(
            Colors.green(
                `\nRun ${Colors.magenta(`commandkit start`)} ${Colors.green('to start your bot.')}`,
            ),
        );
    } catch (e) {
        status.fail(`Build failed after ${(performance.now() - start).toFixed(2)}ms!`);
        panic(e);
    }
}

export async function injectShims(outDir, main, antiCrash, polyfillRequire) {
    const path = join(process.cwd(), outDir, main);

    const head = ['\n\n;await (async()=>{', "  'use strict';"].join('\n');
    const tail = '\n})();';
    const requireScript = polyfillRequire
        ? [
              '// --- CommandKit require() polyfill ---',
              '  if (typeof require === "undefined") {',
              '    const { createRequire } = await import("node:module");',
              '    const __require = createRequire(import.meta.url);',
              '    Object.defineProperty(globalThis, "require", {',
              '      value: (id) => {',
              '        return __require(id);',
              '      },',
              '      configurable: true,',
              '      enumerable: false,',
              '      writable: true,',
              '    });',
              '  }',
              '// --- CommandKit require() polyfill ---',
          ].join('\n')
        : '';

    const antiCrashScript = antiCrash
        ? [
              '// --- CommandKit Anti-Crash Monitor ---',
              "  // 'uncaughtException' event is supposed to be used to perform synchronous cleanup before shutting down the process",
              '  // instead of using it as a means to resume operation.',
              '  // But it exists here due to compatibility reasons with discord bot ecosystem.',
              "  const p = (t) => `\\x1b[33m${t}\\x1b[0m`, b = '[CommandKit Anti-Crash Monitor]', l = console.log, e1 = 'uncaughtException', e2 = 'unhandledRejection';",
              '  if (!process.eventNames().includes(e1)) // skip if it is already handled',
              '    process.on(e1, (e) => {',
              '      l(p(`${b} Uncaught Exception`)); l(p(b), p(e.stack || e));',
              '    })',
              '  if (!process.eventNames().includes(e2)) // skip if it is already handled',
              '    process.on(e2, (r) => {',
              '      l(p(`${b} Unhandled promise rejection`)); l(p(`${b} ${r.stack || r}`));',
              '    });',
              '// --- CommandKit Anti-Crash Monitor ---',
          ].join('\n')
        : '';

    const contents = await readFile(path, 'utf-8');
    const finalScript = [head, requireScript, antiCrashScript, tail, '\n\n', contents].join('\n');

    return writeFile(path, finalScript);
}
